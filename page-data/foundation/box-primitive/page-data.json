{"componentChunkName":"component---src-pages-mdx-slug-tsx","path":"/foundation/box-primitive/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Box Primitive\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Box Primitive\"), mdx(\"h2\", null, \"Box as Layout Component\"), mdx(\"p\", null, \"As the basis of all our components, we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Box>\"), \". It is a versatile layout component that\\ncan be modified with layout props as listed in the \", mdx(Link, {\n    to: \"../../components/box\",\n    mdxType: \"Link\"\n  }, \"Box component\"), \" description.\\nAdditionally, use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"variant\"), \" prop to define custom styles in your themes. With the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \" prop, you\\ndetermine the rendered HTML element. Instead of exposing the underlying tools that will create CSS, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Box>\"), \" component\\nwraps them and exposes an API for applying styling to a component while respecting the rules and constraints of our design\\nsystem.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"code\",\n    \"code\": true\n  }, \"import { Box } from '@marigold/components';\\nimport { useStyles } from '@marigold/system';\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"live\",\n    \"live\": true\n  }, \"<Box as=\\\"button\\\" bg=\\\"orange\\\" p=\\\"8px\\\">\\n  Button box with backgroundcolor and padding\\n</Box>\\n\")), mdx(\"h2\", null, \"Building a custom Component with the Box\"), mdx(\"p\", null, \"In case you want to build your own custom component, use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box\"), \" as the underlying layout component and add\\nthe styles accordingly. You can stack and nest multiple Box instances and build your complex component like this.\\nBy default, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box\"), \" component will render a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<div />\"), \". This might be fine most of the times, but sometimes you would\\nrather render a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<button>\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<input>\"), \" etc. To allow this, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Box\"), \" takes the special prop called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"as\"), \", accepting\\nall HTML tag names as input. Don't forget to define variants in your theme.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"code\",\n    \"code\": true\n  }, \"export type ButtonProps = {\\n  variant?: string;\\n} & ComponentPropsWithRef<'button'>;\\n\\nexport const Button: React.FC<ButtonProps> = ({\\n  variant = 'primary.large',\\n  children,\\n  ...props\\n}) => {\\n  return (\\n    <Box as=\\\"button\\\" {...props} variant={`button.${variant}`}>\\n      <Box as=\\\"span\\\" display=\\\"inline-flex\\\" alignItems=\\\"center\\\">\\n        {children}\\n      </Box>\\n    </Box>\\n  );\\n};\\n\")), mdx(\"h2\", null, \"Custom CSS\"), mdx(\"p\", null, \"Staying inside the boundaries of the design system and its contraints should be the norm. But as limiting styling only\\nto allowed values defined by the system can be very restrictive, you can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"className\"), \" prop and generate custom\\nstyles with the \", mdx(Link, {\n    to: \"../../guides/usestyles\",\n    mdxType: \"Link\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useStyles\")), \" hook.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-tsx\",\n    \"metastring\": \"code\",\n    \"code\": true\n  }, \"...\\n    <Box\\n      as=\\\"button\\\"\\n      className={useStyles({ css: { fontSize: '11pt' } })}\\n      {...props}\\n      variant={`button.${variant}`}\\n    >\\n      ...\\n    </Box>\\n...\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Box Primitive"},"headings":[{"value":"Box Primitive"}]}},"pageContext":{"id":"edee1aaf-674d-56b9-8a19-8d80cebb7df3","slug":"foundation/box-primitive","__params":{"slug":"foundation"}}},"staticQueryHashes":["3402178641"]}